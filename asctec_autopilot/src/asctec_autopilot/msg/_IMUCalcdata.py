# autogenerated by genmsg_py from IMUCalcdata.msg. Do not edit.
import roslib.message
import struct


class IMUCalcdata(roslib.message.Message):
  _md5sum = "e0e3f42a8742d7a0cc87047462b5e80d"
  _type = "asctec_autopilot/IMUCalcdata"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """# angles derived by integration of gyro_outputs, drift compensated by data fusion; -90000..+90000 pitch(nick) and roll, 0..360000 yaw; 1000 = 1 degree

int64 angle_roll
int64 angle_pitch
int64 angle_yaw

# acc-sensor outputs, calibrated: -10000..+10000 = -1g..+1g

int64 acc_x_calib
int64 acc_y_calib
int64 acc_z_calib

# horizontal / vertical accelerations: -10000..+10000 = -1g..+1g

int64 acc_x
int64 acc_y
int64 acc_z

# height in mm (after data fusion)

int64 height

# height from sensor in mm

int64 height_reference


"""
  __slots__ = ['angle_roll','angle_pitch','angle_yaw','acc_x_calib','acc_y_calib','acc_z_calib','acc_x','acc_y','acc_z','height','height_reference']
  _slot_types = ['int64','int64','int64','int64','int64','int64','int64','int64','int64','int64','int64']

  ## Constructor. Any message fields that are implicitly/explicitly
  ## set to None will be assigned a default value. The recommend
  ## use is keyword arguments as this is more robust to future message
  ## changes.  You cannot mix in-order arguments and keyword arguments.
  ##
  ## The available fields are:
  ##   angle_roll,angle_pitch,angle_yaw,acc_x_calib,acc_y_calib,acc_z_calib,acc_x,acc_y,acc_z,height,height_reference
  ##
  ## @param self: self
  ## @param args: complete set of field values, in .msg order
  ## @param kwds: use keyword arguments corresponding to message field names
  ## to set specific fields. 
  def __init__(self, *args, **kwds):
    if args or kwds:
      super(IMUCalcdata, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.angle_roll is None:
        self.angle_roll = 0
      if self.angle_pitch is None:
        self.angle_pitch = 0
      if self.angle_yaw is None:
        self.angle_yaw = 0
      if self.acc_x_calib is None:
        self.acc_x_calib = 0
      if self.acc_y_calib is None:
        self.acc_y_calib = 0
      if self.acc_z_calib is None:
        self.acc_z_calib = 0
      if self.acc_x is None:
        self.acc_x = 0
      if self.acc_y is None:
        self.acc_y = 0
      if self.acc_z is None:
        self.acc_z = 0
      if self.height is None:
        self.height = 0
      if self.height_reference is None:
        self.height_reference = 0
    else:
      self.angle_roll = 0
      self.angle_pitch = 0
      self.angle_yaw = 0
      self.acc_x_calib = 0
      self.acc_y_calib = 0
      self.acc_z_calib = 0
      self.acc_x = 0
      self.acc_y = 0
      self.acc_z = 0
      self.height = 0
      self.height_reference = 0

  ## internal API method
  def _get_types(self): return self._slot_types

  ## serialize message into buffer
  ## @param buff StringIO: buffer
  def serialize(self, buff):
    try:
      buff.write(struct.pack('<11q', self.angle_roll, self.angle_pitch, self.angle_yaw, self.acc_x_calib, self.acc_y_calib, self.acc_z_calib, self.acc_x, self.acc_y, self.acc_z, self.height, self.height_reference))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  ## unpack serialized message in str into this message instance
  ## @param self: self
  ## @param str str: byte array of serialized message
  def deserialize(self, str):
    try:
      end = 0
      start = end
      end += 88
      (self.angle_roll, self.angle_pitch, self.angle_yaw, self.acc_x_calib, self.acc_y_calib, self.acc_z_calib, self.acc_x, self.acc_y, self.acc_z, self.height, self.height_reference,) = struct.unpack('<11q',str[start:end])
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill


  ## serialize message with numpy array types into buffer
  ## @param self: self
  ## @param buff StringIO: buffer
  ## @param numpy module: numpy python module
  def serialize_numpy(self, buff, numpy):
    try:
      buff.write(struct.pack('<11q', self.angle_roll, self.angle_pitch, self.angle_yaw, self.acc_x_calib, self.acc_y_calib, self.acc_z_calib, self.acc_x, self.acc_y, self.acc_z, self.height, self.height_reference))
    except struct.error, se: self._check_types(se)
    except TypeError, te: self._check_types(te)

  ## unpack serialized message in str into this message instance using numpy for array types
  ## @param self: self
  ## @param str str: byte array of serialized message
  ## @param numpy module: numpy python module
  def deserialize_numpy(self, str, numpy):
    try:
      end = 0
      start = end
      end += 88
      (self.angle_roll, self.angle_pitch, self.angle_yaw, self.acc_x_calib, self.acc_y_calib, self.acc_z_calib, self.acc_x, self.acc_y, self.acc_z, self.height, self.height_reference,) = struct.unpack('<11q',str[start:end])
      return self
    except struct.error, e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill

